#!/bin/bash
# ecsssh
#
# Given an ECS service, ssh to any EC2 instance running it.

set -e
set -o pipefail


check_dependencies () {
    if ! command -v jq > /dev/null ; then
        echo "Please install jq (https://stedolan.github.io/jq/)" ; exit 1
    fi
    if ! command -v fzf > /dev/null ; then
        echo "Please install fzf (https://github.com/junegunn/fzf)" ; exit 1
    fi
    if ! command -v aws > /dev/null ; then echo "Please install aws" ; exit 1 ; fi
}


usage () {
    cat <<.
Usage: $(basename "$0")
    -h, --help          Show this message and exit.
    -j, --just-show     Just show the IP address. Don't ssh to the instance.

By default this tool connects using 'ssh'. To connect using 'mssh' set this env var:

    EC2_SSH_BINARY=mssh
.
}

die() { echo "$*" >&2; exit 2; }            # complain to STDERR and exit with error
needs_arg() { if [ -z "$OPTARG" ]; then die "No arg for --$OPT option"; fi; }
no_arg() { if [ -n "$OPTARG" ]; then die "No arg allowed for --$OPT option"; fi; }

parse_opts () {

    # Default values.
    just_show="false"

    # Parse arguments. Supports long options on Linux and MacOS (without getopt).
    # https://stackoverflow.com/a/28466267
    while getopts u,h,j,-: OPT; do
      if [ "$OPT" = "-" ]; then   # long option: reformulate OPT and OPTARG
        OPT="${OPTARG%%=*}"       # extract long option name
        OPTARG="${OPTARG#$OPT}"   # extract long option argument (may be empty)
        OPTARG="${OPTARG#=}"      # if long option argument, remove assigning `=`
      fi
      case "$OPT" in
        u | usage )     usage && exit ;;
        h | help )      usage && exit ;;
        j | just-show ) no_arg; just_show="true" ;;
        ??* )           die "Illegal option --$OPT" ;;  # bad long option
        \? )            exit 2 ;;  # bad short option (error reported via getopts)
      esac
    done
    shift $((OPTIND-1)) # remove parsed options and args from $@ list

    # Parse arguments.
    if [ $# != 0 ] ; then usage && exit 1 ; fi
}

case "${EC2_SSH_BINARY}" in
    "ssh") ssh_binary=ssh ;;
    "mssh") ssh_binary=mssh ;;
    *) ssh_binary=ssh ;;
esac

check_dependencies
parse_opts "$@"


cluster=$(
    aws ecs list-clusters | jq -r '.clusterArns[]' \
    | fzf -0 --prompt 'cluster> ')

service=$(
    aws ecs list-services --cluster "${cluster}" | jq -r '.serviceArns[]' \
    | cut -d'/' -f2- | fzf -0 --prompt 'service> ')

task_ids=$(aws ecs list-tasks --cluster $cluster --service $service \
    | jq -r '.taskArns[]')

c_instance=$(
    aws ecs describe-tasks --cluster $cluster --tasks $task_ids \
    | jq -r '.tasks[] | [ .lastStatus, .containerInstanceArn ] | @tsv' \
    | fzf -0 --prompt 'task> '\
    | awk '{print $2}')

instance_id=$(
    aws ecs describe-container-instances --cluster "${cluster}" \
    --container-instances "${c_instance}" \
    | jq -r '.containerInstances[].ec2InstanceId')

private_ip=$(
    aws ec2 describe-instances --output json \
    --filters "Name=instance-id,Values=${instance_id}" \
    --query 'Reservations[].Instances[]' \
    | jq -r '.[].PrivateIpAddress')

image_id=$(
    aws ec2 describe-instances --output json \
    --filters "Name=instance-id,Values=${instance_id}" \
    | jq -r '.Reservations[].Instances[].ImageId')

ssh_user=$(
    aws ec2 describe-images --image-ids "${image_id}" \
    | jq -r '.Images[]? | .Name,.Tags[]?.Value' \
    | grep -q -i ubuntu \
    && echo ubuntu || echo ec2-user
)

if [ "${just_show}" = "true" ] ; then
    echo "${private_ip}"
    exit 0
fi


if [ "${ssh_binary}" = "mssh" ] ; then
    ssh_cmd="mssh -t ${instance_id} ${ssh_user}@${private_ip}"
else
    ssh_cmd="ssh -l ${ssh_user} ${private_ip}"
fi

$ssh_cmd
