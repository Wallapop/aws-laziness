#!/bin/bash
# ec2ssh

cache='/tmp/ec2ssh.cache'


check_dependencies () {
    if ! command -v jq > /dev/null ; then
        echo "Please install jq (https://stedolan.github.io/jq/)" ; exit 1
    fi
    if ! command -v fzf > /dev/null ; then
        echo "Please install fzf (https://github.com/junegunn/fzf)" ; exit 1
    fi
    if ! command -v aws > /dev/null ; then echo "Please install aws" ; exit 1 ; fi
}


usage () {
    cat <<.
Usage: $(basename "$0")
    -h    Show this message and exit.
    -e    Work on this environment (default: prod).
    -f    Flush cached data.

By default this tool connects using 'ssh'. To connect using 'mssh' set this env var:

    EC2_SSH_BINARY=mssh
.
}

parse_opts () {
    # Default values.
    env="prod"

    # Parse arguments.
    while getopts u,h,e:,f OPT; do
        case "${OPT}" in
            u|h)    usage && exit ;;
            e)      env="${OPTARG}" ;;
            f)      flush_cache && exit ;;
            \? )    echo && usage && exit 1 ;;
        esac
    done
    shift $((OPTIND-1)) # remove parsed options and args from $@ list

    # Finish if received some unknown option.
    if [ $# != 0 ] ; then usage && exit 1 ; fi
}


get_ec2roles () {
    # Retrieves all EC2 tags "Role"
    aws ec2 describe-instances --no-paginate --output json \
        --query "Reservations[].Instances" \
        --filters "Name=tag:Env,Values=${env}" "Name=instance-state-name,Values=running" \
    | jq -r '.[][].Tags[] | select(.Key=="Role") | .Value' \
    | sort | uniq
}


flush_cache () {
    rm -f ${cache}/*.roles
}


ec2roles () {
    # Remove empty cache files.
    if [ ! -s "${cache}/${env}.roles" ] ; then
        rm -f "${cache}/${env}.roles"
    fi
    if [ ! -f "${cache}/${env}.roles" ] ; then
        get_ec2roles > "${cache}/${env}.roles"
    fi
    fzf --prompt "Role> " < "${cache}/${env}.roles"
}


ec2instances () {
    aws ec2 describe-instances --no-paginate --output json \
        --filters "Name=tag:Env,Values=${env}" "Name=tag:Role,Values=${role}" \
                  "Name=instance-state-name,Values=running" \
        --query "Reservations[].Instances"
}


jq_name_and_ip () {
    cat <<.
        .[][] |
        # enrich all tags with IP address
        .Tags[] + { "Ip": .PrivateIpAddress, "InstanceId": .InstanceId } |
        # keep only tags with Key="Name"
        select(.Key=="Name") |
        [ .Value, .Ip, .InstanceId ] | @tsv
.
}


check_dependencies

case "${EC2_SSH_BINARY}" in
    "ssh")      ssh_binary=ssh ;;
    "mssh")     ssh_binary=mssh ;;
    *)          ssh_binary=ssh ;;
esac

parse_opts "$@"

# Create cache dir, if needed.
[ -d ${cache} ] || mkdir ${cache}

role=$(ec2roles)
host_and_addr=$(ec2instances | jq -r -f <(jq_name_and_ip) | fzf -n1 --prompt "Host> ")
addr=$(echo "${host_and_addr}" | awk '{print $2}')
instance_id=$(echo "${host_and_addr}" | awk '{print $3}')

image_id=$(
    aws ec2 describe-instances --output json \
    --filters "Name=instance-id,Values=${instance_id}" \
    | jq -r '.Reservations[].Instances[].ImageId')

ssh_user=$(
    ami_name=$(aws ec2 describe-images --image-ids "${image_id}" \
        | jq -r '.Images[]? | .Name,.Tags[]?.Value')
    if echo "${ami_name}" | grep -E -q -i 'ubuntu|mongoose' ; then
        echo ubuntu
    else
        echo ec2-user
    fi
)

# Remove the local functions from global env.
unset -f jq_name_and_ip
unset -f ec2instances
unset -f ec2roles
unset -f get_ec2roles


echo "${host_and_addr}"

if [ "${ssh_binary}" = "mssh" ] ; then
    mssh ${ssh_user}@${instance_id}
else
    ssh -l ${ssh_user} "${addr}"
fi
